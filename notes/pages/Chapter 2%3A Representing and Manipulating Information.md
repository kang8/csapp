- 信息的表示与处理。
  
  讲述了计算机的算术运算；数字是如何表示的；IEEE 标准的浮点格式；
- 现代计算机存储合处理的信息以二值信号表示，通常称为位（ [[bit]] ）
- 本章将研究三种数字表示方法
	- 无符号（unsigned）编码
	- 补码（two's-complement）编码
	- 浮点数（floating-point）编码
- 整数只能编码较小的数值范围，但这种表示是精确的；
  浮点数能编码较大的数值范围，但这种表示是近似的。
- ---
- 2.1 Information Storage
	- 大多数计算机使用 8 位的块，或称字节（ [[byte]] ），作为最小的可寻址的内存单位。
	- 2.1.1 Hexadecimal Notation
		- 通常使用**十六进制表示法**表示字节。因为二进制表示法太冗长，而十进制表示法与位模式的互相在转化很麻烦。
		- 介绍了多种快速在二进制、十六进制、十进制之前的转换：
			- 4 个二进制表示一个十六进制。
			- 将 $$2^n$$ 转换成十六进制形式时，也可以用 4 个二进制表示一个十六进制的方法来表示。
			- 十进制转换成十六进制通过除以 16 拿到余数解决。十六进制转换成十进制通过乘 16 解决。
	- 2.1.2 Data Sizes
		- 每台计算机都有字长（word size），表示**指针**数据的标称大小（nominal size）。虚拟地址的大小就是字长的大小，对于字长为 32 位的机器而言，虚拟地址的范围为 $$2^{32} - 1 = 4294967295$$
		- 大多数 64 位机器可以运行 32 位机器编译的程序，但是反过来就不行。
			- ```bash
			  $ gcc -m32 prog.c # compile prog.c to 32-bit programs
			  $ gcc -m64 prog.c # compile prog.c to 64-bit programs
			  ```
			  
			  #gcc
		- C 语言的数据类型在 32 位和 64 位上大体相同，但有两个例外
			- long, 32-bit is 4 bytes, 64-bit is 8 bytes
			- pointer, 32-bit is 4 bytes, 64-bit is 8 bytes
				- 指针是编写可移植性代码的一大难题。C 语言标准对不同数据类型的数字范围设置了下界，但是却没有上界。这会造成一个声明为 int 类型的程序对象能被用来存储一个指针，这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。
		- ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。
			- int32_t，表示 4 个字节
			- int64_t，表示 8 个字节
	- 2.1.3 Addressing and Byte Ordering
		- 计算机在内存中排列字节的方式有两种
			- 小端法（little endian）：最高有效字节在最前面
			- 大端法（big endian）：最高有效字节在最前面
			- 例如，在字 0x01234567 中，大端法表示为 0x01234567，小端法表示为 0x67452301
		- 选择何种字节顺序并没有技术上的理由。只要选择了一种规则并且始终如一地坚持就行。但由于存在两种不同的字节顺序，字节顺序会在下面情况会成为问题
			- 在不同的字节顺序机器之前进行网络传输时。解决办法通常是引入中间层进行转换
			- 小端法的表示法（与阅读的自然方式相背）将会造成阅读体验差
			- 编写规避正常的类型系统的程序时，在 C 语言中是强制转换或联合。在 C 语言对于指针的处理，某些情况下要考虑大端小端问题